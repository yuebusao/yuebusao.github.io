<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>换博客啦</title>
      <link href="/2022/11/14/huan-bo-ke-la/"/>
      <url>/2022/11/14/huan-bo-ke-la/</url>
      
        <content type="html"><![CDATA[<p>服务器马上过期了，还记得一年前花了几十块买了一年的腾讯云服务器，当时认为腾讯真大气，毕竟国外的vps一年都得一百多。如今一年之约已到，一看续费人晕掉了。一个月140人民币，这是抢钱啊！！！因此火速转移到hexo+github。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国内服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计基础—架构</title>
      <link href="/2021/11/12/java-dai-ma-shen-ji-ji-chu-jia-gou/"/>
      <url>/2021/11/12/java-dai-ma-shen-ji-ji-chu-jia-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="Java审计基础—架构"><a href="#Java审计基础—架构" class="headerlink" title="Java审计基础—架构"></a>Java审计基础—架构</h3><blockquote><p>架构的目的就是分层，使得职能分离。</p></blockquote><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul><li>M 代表 模型（Model）：用来取数据的，我的理解是充当DAO层以及POJO这些。</li><li>V 代表 视图（View）：负责页面展示。</li><li>C 代表 控制器（Controller) ：处理逻辑，控制页面跳转。</li></ul><p>这样的目的主要是把View和Model分离，改样式就动View层，Controller负责逻辑，也就是与V和M之间的联系。</p><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><p>可以看到MVC分离的还不够细化，因此SpringMVC实现了把控制器分为控制层以及业务层（实际上咱现在用的基本都是SpringMVC以及SpringBoot这种）</p><p>SpringMVC：视图层调用控制层，控制层调用业务层，业务层调用数据访问层。</p><p><strong>数据访问层</strong>：data access object(DAO)，DAO就是封装实体类在数据库中增删改查的操作。</p><p><strong>业务层</strong>：用来写业务逻辑的<br>对于Service，就是 Servlet 和 Dao 层之间缓冲的层。通过这一层来进行解耦，使得 Dao 层内的变化不会直接影响到 Servlet 层。</p><p><strong>控制层</strong>：MVC中的Controller，用于处理前端页面跳转，调用业务层实现前端页面动态数据的展示。</p><p><strong>视图层</strong>：页面展示。</p><h4 id="JAVAEE分层模型"><a href="#JAVAEE分层模型" class="headerlink" title="JAVAEE分层模型"></a>JAVAEE分层模型</h4><p>就是SpringMVC，除此之外多了一个DO。<br><strong>Domain Object(领域对象)层</strong></p><p>DO是从现实世界中抽象出来的有形或无形的业务实体。</p><p>说白了像一个entity对应一张表叫DO。</p><p><strong>DAO(数据访问对象)层</strong><br>DAO实现了对数据库的CRUD等常见操作。</p><p><strong>Service(业务逻辑)层</strong><br>实现了系统所需要的业务逻辑方法。</p><p><strong>Controller(控制器)层</strong><br>本层由一系列控制器组成，这些控制器用于拦截用户的请求，并调用业务逻辑组件的业务逻辑方法去处理用户请求，然后根据处理结果向不同的View组件转发。</p><p><strong>View(表现层)层</strong><br>页面展示。</p><p>分层模型图如下：</p><p><img src="https://img-blog.csdnimg.cn/3a9d1d1175bf4645b35363b16a857e90.png#pic_center" alt="出自JAVA代码安全审计"></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>1.Java代码安全审计（入门篇）                徐焱</p><p>2.<a href="https://blog.csdn.net/weixin_45442296/article/details/123111903">https://blog.csdn.net/weixin_45442296/article/details/123111903</a>      JavaRange</p><p>3.<a href="https://blog.csdn.net/qq_43391574/article/details/110944815">https://blog.csdn.net/qq_43391574/article/details/110944815</a>             落雨青石街</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC Java安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础命令学习</title>
      <link href="/2021/11/05/docker-ji-chu-ming-ling-xue-xi/"/>
      <url>/2021/11/05/docker-ji-chu-ming-ling-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search xxx</span><br><span class="line">docker search --filter=STARS=1000       #过滤，指定搜索stars大于1000的镜像</span><br></pre></td></tr></table></figure><p>search指令可以搜索指定名称或者仓库的镜像的信息。</p><ol><li>STARS: 镜像的stars—越高越受欢迎，</li><li>OFFICIAL: 是否是官方提供的</li><li>AUTOMATED:  是不是自动化的</li></ol><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull xxx</span><br><span class="line">docker pull xxx:tag       #指定版本</span><br></pre></td></tr></table></figure><p>把指定镜像拉到本地仓库，默认为拉取最新版本。可以通过[镜像:版本号]的形式指定对应版本号的镜像下载，例如：docker pull mysql:5.6.50</p><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images || docker images -a  #查看镜像所有信息</span><br><span class="line">docker images -aq                  #查看镜像id</span><br></pre></td></tr></table></figure><ol><li>REPOSITORY: 镜像仓库名</li><li>TAG:                镜像标签</li><li>IMAGE ID:       镜像id</li><li>CREATED:          镜像创建时间</li><li>SIZE:                镜像大小</li></ol><h4 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run xxx      #指定xxx镜像生成容器</span><br><span class="line">docker run -p 8080:8080 -d xxx  #容器内部8080端口映射到本地8080端口，并守护进程后台运行</span><br></pre></td></tr></table></figure><ul><li><p>-p：容器内部端口绑定到指定的主机端口</p></li><li><p>-P：容器内部端口随机映射到主机的端口</p></li><li><p>-t：提供终端输入</p></li><li><p>-i：提供交互</p></li><li><p>-d：容器在后台运行</p></li></ul><h4 id="查看镜像状态"><a href="#查看镜像状态" class="headerlink" title="查看镜像状态"></a>查看镜像状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps          #查看正在运行中的的容器</span><br><span class="line">docker ps -a       #查看所有容器</span><br><span class="line">docker ps -q       #看正在运行中的的容器：仅列出编号</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop xxx      #指定编号</span><br></pre></td></tr></table></figure><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start XXX         #指定编号</span><br></pre></td></tr></table></figure><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart xxx      #指定编号</span><br></pre></td></tr></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm xxxxxxxxxx      # 删除指定容器</span><br><span class="line">docker rm -f xxxxxxxxxx  # 强制删除运行中的容器</span><br><span class="line">docker rm -f $(docker ps -aq) # 迭代删除全部的容器</span><br></pre></td></tr></table></figure><h4 id="进入容器的bash"><a href="#进入容器的bash" class="headerlink" title="进入容器的bash"></a>进入容器的bash</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it xxxxx /bin/bash   # 进入到指定容器内部进行修改  开启一个新的终端</span><br><span class="line">exit        #退出bash</span><br></pre></td></tr></table></figure><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp ./flag xx:/var/www/html/flag      #将当前目录的flag拷贝到指定为xx id的容器/var/www/html/flag中</span><br><span class="line">cp xx:/var/www/html/flag .flag #将指定为xx id的容器/var/www/html下的flag文件拷贝到当前目录flag文件中</span><br></pre></td></tr></table></figure><h4 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>之后就是联动vulhub一键搭环境。</p><h4 id="vulhub一键搭漏洞环境"><a href="#vulhub一键搭漏洞环境" class="headerlink" title="vulhub一键搭漏洞环境"></a>vulhub一键搭漏洞环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先进入对应漏洞环境的文件夹</span></span><br><span class="line">Docker-compose up -d  #根据docker-compose.yml自动拉取容器并启动。</span><br></pre></td></tr></table></figure><p>tomcat8的docker-compose.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">tomcat:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">vulhub/tomcat:8.0</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./tomcat-users.xml:/usr/local/tomcat/conf/tomcat-users.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./context.xml:/usr/local/tomcat/webapps/manager/META-INF/context.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./context.xml:/usr/local/tomcat/webapps/host-manager/META-INF/context.xml</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我介绍</title>
      <link href="/2021/10/31/zi-wo-jie-shao/"/>
      <url>/2021/10/31/zi-wo-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>我是Squirt1e，坐标北京，是一名即将步入研究生阶段的web🐕。</p><p>我的梦想是成为安全研究员，并且做出一些有用的工作，但这个梦想可能难以实现。一个原因是研究生阶段的方向可能与web安全研究出入比较大，我早就知道研究生不太可能做“传统”网安。但从导师那里得知自己和“传统”网安无缘，是有一点点失望。另一个原因是我比较菜，各位师傅看我的文章就知道我的水平并不高，同年龄段大师傅的仓库里0day满天飞，而我还在思考CMS的代码为什么这么写。菜的原因（我不承认我脑袋不行:&gt;）大概是因为大一我在摆烂，而大二大三在卷一些实际用处不大的东西。</p><p>尽管如此，我还是想尝试坚持一下，毕竟web安全是我目前唯一感兴趣的点。这个博客算是用来督促我学习web的，争取每周发一篇认真去思考打磨的文章。等我认为博客质量过关了，我才会去发安全研究分类的文章。</p><p>联系方式：<a href="mailto:&#49;&#51;&#x30;&#x33;&#x35;&#49;&#x36;&#50;&#48;&#52;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#49;&#51;&#x30;&#x33;&#x35;&#49;&#x36;&#50;&#48;&#52;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于Squirt1e </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
